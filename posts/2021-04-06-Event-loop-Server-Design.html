<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" type="image/x-icon" href="images/favicon.ico" />
        <title>Blog - Event-loop server design</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../pert.html">PERT</a>
                <a href="../about.html">About</a>
            </nav>
        </header>

        <main role="main">
            <article>
    <section class="header">
        <h1>Event-loop server design</h1>
        <div class="meta">[2021-04-06] </div>
        <p>I briefly go over the event-loop design for servers that need to handle a high number of simultaneous connections</p>
    </section>
    <section>
        <p>In the last decades best-practices of server design have been updated to support many concurrent clients. Rise of the Internet, service-oriented architectures and demand for online services all contributed to a push for designs that can handle more clients with less resources. There are many strategies how to design IO intensive servers, most of them are described in the popular <a href="http://www.kegel.com/c10k.html">C10K</a> article.</p>
<p>In the web-server space the design moved from thread-based request handling (vulnerable to the <a href="https://en.wikipedia.org/wiki/Slowloris_(computer_security)">SlowLoris</a> attack) to event-loop driven architectures represented by the <a href="https://www.nginx.com/">NGINX</a> and <a href="https://nodejs.org">Node.js</a> projects.</p>
<p>The <code>event</code> in the event-loop usually representens any activity on a socket (e.g. socket is ready to be read/written, timeouts, errors ..). There is a single thread (the “loop”) that is notified about such activity and creates the <code>event</code> that is then stored on some queue. <code>Event</code>s from the queue are processed by a dedicated thread pool. The point is not to block the event-loop.</p>
<p>The implementaion details of the event-loop may vary from system to system. For example:</p>
<ul>
<li>is it faster if the <code>event</code> is handled directly by the event-loop thread (i.e. does the <code>event</code> need to be queued)?</li>
<li>Are there more <code>event</code> queues?</li>
</ul>
<p>These considerations are specific to the system you are building.</p>
<p>The socket activity notifications in Linux (inside the event-loop) can be done by a system call. <a href="https://events19.linuxfoundation.org/wp-content/uploads/2018/07/dbueso-oss-japan19.pdf">Performance-wise</a> the <a href="https://man7.org/linux/man-pages/man7/epoll.7.html">epoll API</a> is currently considered as the most scalable. Some systems do not support <code>epoll</code> so it’s better to use a library that picks the fastest kernel API that is available on the given OS. Some of those libraries are <a href="https://github.com/libuv/libuv">libuv</a> (created by and used in Node.js), <a href="http://software.schmorp.de/pkg/libev.html">libev</a> and <a href="https://libevent.org/">libevent</a>. There is a <a href="http://libev.schmorp.de/bench.html">benchmarking test</a> of libevent vs. libev if you are interested in performance comparisons.</p>
<p>To summarize the key points of the event-loop design are:</p>
<ul>
<li>one thread (event-loop) can handle all socket activity,</li>
<li>the kernel API can provide the notifications about socket activity,</li>
<li>use a library (libuv, libev, libevent…) for software portability,</li>
<li>processing of events (i.e. when long blocking synchronous calls are triggered) must happen outside the event-loop.</li>
</ul>
    </section>
    <nav>
        <a href="../">back</a>
    </nav>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>

    </body>
</html>
